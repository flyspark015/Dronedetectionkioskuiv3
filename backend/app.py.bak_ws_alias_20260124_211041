#!/usr/bin/env python3
import json, os, time, threading, socket
from typing import Any, Dict, Optional, Set, List, Tuple
from collections import deque

from flask import Flask, jsonify
from flask_sock import Sock

APP_PORT = 8000
STATE_DIR = "/opt/ndefender/backend/state"
REMOTEID_STATE_FILE = os.path.join(STATE_DIR, "remoteid_state.json")
GPS_STATE_FILE = os.path.join(STATE_DIR, "gps_state.json")

RAW_JSONL_PATH = "/opt/ndefender/logs/remoteid_replay.jsonl"
EK_JSONL_PATH  = "/opt/ndefender/logs/odid_wifi_sample.ek.jsonl"

# Phase-1.1 replay-only
RID_TTL_S = 15.0
RID_REPLAY_LOOP = False          # one-shot so LOST can be proven
RID_REPLAY_SLEEP_S = 0.01
RID_STATS_PERIOD_S = 1.0

app = Flask(__name__)
sock = Sock(app)

_ws_clients_lock = threading.Lock()
_ws_clients: Set[Any] = set()
_stop = threading.Event()

# Global tracker ref for WS snapshots
_TRACKER = None

def now_ts() -> float:
    return time.time()

def atomic_write_json(path: str, obj: Dict[str, Any]) -> None:
    tmp = f"{path}.tmp"
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, separators=(",", ":"))
    os.replace(tmp, path)

def safe_load(path: str, default: Dict[str, Any]) -> Dict[str, Any]:
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default

def ws_broadcast(obj: Dict[str, Any]) -> None:
    payload = json.dumps(obj, separators=(",", ":"), ensure_ascii=False)
    dead: List[Any] = []
    with _ws_clients_lock:
        for ws in list(_ws_clients):
            try:
                ws.send(payload)
            except Exception:
                dead.append(ws)
        for ws in dead:
            _ws_clients.discard(ws)

def _float(v: Any) -> Optional[float]:
    try:
        if v is None:
            return None
        return float(v)
    except Exception:
        return None

def _str(v: Any) -> Optional[str]:
    if v is None:
        return None
    try:
        s = str(v)
        return s if s != "" else None
    except Exception:
        return None

def _get_any(d: Dict[str, Any], keys: List[str]) -> Any:
    for k in keys:
        if k in d:
            return d[k]
    return None

def parse_any_json_line(line: str) -> Optional[Dict[str, Any]]:
    line = line.strip()
    if not line:
        return None
    # ignore ES bulk index lines if present
    if line.startswith('{"index"'):
        return None
    try:
        return json.loads(line)
    except Exception:
        return None

def normalize_event(obj: Dict[str, Any], source: str) -> Optional[Dict[str, Any]]:
    ts = _float(_get_any(obj, ["ts", "timestamp", "@timestamp"]))
    if ts is None:
        ts = _float(obj.get("timestamp"))
    if ts is None:
        ts = now_ts()

    layers = obj.get("layers") if isinstance(obj.get("layers"), dict) else None
    flat = layers if layers is not None else obj

    def pick(k: str) -> Any:
        v = flat.get(k)
        if isinstance(v, list) and v:
            return v[0]
        return v

    fn = pick("frame.frame_number") or pick("frame_frame_number") or obj.get("frame_frame_number")
    try:
        frame_no = int(fn) if fn is not None else None
    except Exception:
        frame_no = None

    msg_type    = _str(pick("OpenDroneID.msgType") or pick("opendroneid.msgType"))
    operator_id = _str(pick("OpenDroneID.operator_id") or pick("OpenDroneID.operatorId") or pick("opendroneid.operator_id"))
    basic_id    = _str(pick("OpenDroneID.basicID_id_asc") or pick("OpenDroneID.basicid_id_asc") or pick("opendroneid.basicID_id_asc"))

    lat = _float(pick("OpenDroneID.loc_lat") or pick("opendroneid.loc_lat"))
    lon = _float(pick("OpenDroneID.loc_lon") or pick("opendroneid.loc_lon"))
    alt_m = _float(pick("OpenDroneID.loc_alt") or pick("OpenDroneID.loc_altitude") or pick("opendroneid.loc_alt"))

    mac = _str(pick("wlan.sa") or pick("wlan.ta") or pick("wlan.da") or pick("wlan.bssid") or pick("eth.src") or pick("btle.address"))

    # raw replay formats
    msg_type = msg_type or _str(_get_any(obj, ["msg_type", "type", "rid_type", "OpenDroneID.msgType"]))
    operator_id = operator_id or _str(_get_any(obj, ["operator_id", "OpenDroneID.operator_id"]))
    basic_id = basic_id or _str(_get_any(obj, ["basic_id", "id", "basicID_id_asc", "OpenDroneID.basicID_id_asc"]))
    lat = lat if lat is not None else _float(_get_any(obj, ["lat", "latitude"]))
    lon = lon if lon is not None else _float(_get_any(obj, ["lon", "longitude"]))
    alt_m = alt_m if alt_m is not None else _float(_get_any(obj, ["alt_m", "alt", "altitude_m"]))

    return {
        "ts": ts,
        "source": source,
        "msg_type": msg_type,
        "operator_id": operator_id,
        "basic_id": basic_id,
        "mac": mac,
        "lat": lat,
        "lon": lon,
        "alt_m": alt_m,
        "frame_no": frame_no,
        "raw": obj,
    }

def ek_dedupe_stream(events: List[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], Dict[str, int]]:
    out: List[Dict[str, Any]] = []
    before = len(events)
    current_frame = None
    seen: Set[Tuple[Any, Any, Any, Any, Any, Any]] = set()
    dupes = 0

    for e in events:
        fn = e.get("frame_no")
        if fn != current_frame:
            current_frame = fn
            seen.clear()

        key = (fn, e.get("msg_type"), e.get("operator_id"), e.get("basic_id"), e.get("lat"), e.get("lon"))
        if fn is not None and key in seen:
            dupes += 1
            continue
        if fn is not None:
            seen.add(key)
        out.append(e)

    after = len(out)
    return out, {"before": before, "after": after, "dupes": dupes}

def stable_contact_id(e: Dict[str, Any]) -> str:
    # LOCKED rules:
    bid = e.get("basic_id")
    if bid:
        return f"rid:{bid}"
    mac = e.get("mac")
    if mac:
        return f"rid:mac:{mac.lower()}"
    raw = json.dumps(e.get("raw", {}), sort_keys=True, separators=(",", ":"))
    h = str(abs(hash((e.get("operator_id"), e.get("lat"), e.get("lon"), raw))))
    return f"rid:hash:{h}"

class ContactTracker:
    def __init__(self, ttl_s: float):
        self.ttl_s = ttl_s
        self.contacts: Dict[str, Dict[str, Any]] = {}
        self.msg_ts_60s = deque()

    def _prune_60s(self, t: float) -> None:
        while self.msg_ts_60s and (t - self.msg_ts_60s[0]) > 60.0:
            self.msg_ts_60s.popleft()

    def ingest(self, e: Dict[str, Any]) -> List[Dict[str, Any]]:
        # message counter uses wall clock
        self.msg_ts_60s.append(now_ts())
        self._prune_60s(now_ts())

        cid = stable_contact_id(e)
        prev = self.contacts.get(cid)

        payload = {
            "id": cid,
            # TTL should be wall-clock based
            "last_ts": now_ts(),
            "source": e.get("source"),
            "msg_type": e.get("msg_type"),
            "operator_id": e.get("operator_id"),
            "basic_id": e.get("basic_id"),
            "mac": e.get("mac"),
            "lat": e.get("lat"),
            "lon": e.get("lon"),
            "alt_m": e.get("alt_m"),
        }

        if prev is None:
            self.contacts[cid] = payload
            return [{"type": "RID_CONTACT_NEW", "ts": now_ts(), "contact": payload}]
        else:
            changed = any(prev.get(k) != payload.get(k) for k in ["msg_type","operator_id","lat","lon","alt_m","mac","basic_id","source"])
            self.contacts[cid].update(payload)
            if changed:
                return [{"type": "RID_CONTACT_UPDATE", "ts": now_ts(), "contact": self.contacts[cid]}]
            return []

    def expire(self) -> List[Dict[str, Any]]:
        t = now_ts()
        lost: List[Dict[str, Any]] = []
        for cid, c in list(self.contacts.items()):
            if (t - float(c.get("last_ts", 0))) > self.ttl_s:
                lost.append({"type": "RID_CONTACT_LOST", "ts": t, "id": cid})
                del self.contacts[cid]
        return lost

    def stats(self) -> Dict[str, Any]:
        t = now_ts()
        self._prune_60s(t)
        return {"targets": len(self.contacts), "msgs_60s": len(self.msg_ts_60s)}

    def snapshot_targets(self) -> List[Dict[str, Any]]:
        return sorted(self.contacts.values(), key=lambda x: x.get("last_ts", 0), reverse=True)

def load_jsonl(path: str, source: str) -> List[Dict[str, Any]]:
    out: List[Dict[str, Any]] = []
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                obj = parse_any_json_line(line)
                if not obj:
                    continue
                e = normalize_event(obj, source=source)
                if e:
                    out.append(e)
    except FileNotFoundError:
        return []
    except Exception:
        return out
    return out

def replay_worker(tracker: ContactTracker) -> None:
    while not _stop.is_set():
        raw_events = load_jsonl(RAW_JSONL_PATH, source="raw_replay")
        ek_events  = load_jsonl(EK_JSONL_PATH,  source="ek_replay")
        ek_events_dedup, dedupe_stats = ek_dedupe_stream(ek_events)

        ws_broadcast({"type": "RID_DEDUPE", "ts": now_ts(), "ek": dedupe_stats})

        # Filter RAW: ignore stats + ignore events without stable identity (basic_id/mac)
        raw_filtered = []
        for e in raw_events:
            mt = (e.get("msg_type") or "").lower()
            if mt.startswith("stats_"):
                continue
            if e.get("basic_id") or e.get("mac"):
                raw_filtered.append(e)

        merged = raw_filtered + ek_events_dedup
        merged.sort(key=lambda e: float(e.get("ts", 0.0)))

        ws_broadcast({"type":"RID_INPUT_COUNTS","ts":now_ts(),"raw_before":len(raw_events),"raw_after":len(raw_filtered),"ek":len(ek_events_dedup)})

        if not merged:
            state = {
                "health": {"state": "DISCONNECTED", "source": "replay", "updated_ts": now_ts()},
                "counts": {"targets": 0, "msgs_60s": 0},
                "targets": [],
                "dedupe": {"ek": dedupe_stats},
            }
            atomic_write_json(REMOTEID_STATE_FILE, state)
            time.sleep(1.0)
            if not RID_REPLAY_LOOP:
                break
            continue

        last_state_write = 0.0
        last_stats_emit = 0.0

        for e in merged:
            if _stop.is_set():
                break

            for ev in tracker.ingest(e):
                ws_broadcast(ev)

            # expire may also be handled by expire_worker, but keep here too
            for ev in tracker.expire():
                ws_broadcast(ev)

            t = now_ts()
            if (t - last_stats_emit) >= RID_STATS_PERIOD_S:
                st = tracker.stats()
                ws_broadcast({"type": "RID_STATS", "ts": t, "counts": st})
                last_stats_emit = t

            if (t - last_state_write) >= 0.5:
                st = tracker.stats()
                state = {
                    "health": {"state": "CONNECTED", "source": "replay", "updated_ts": t},
                    "counts": {"targets": st["targets"], "msgs_60s": st["msgs_60s"]},
                    "targets": tracker.snapshot_targets(),
                    "dedupe": {"ek": dedupe_stats},
                }
                atomic_write_json(REMOTEID_STATE_FILE, state)
                last_state_write = t

            time.sleep(RID_REPLAY_SLEEP_S)

        # After replay ends, mark DEGRADED (no new data)
        t = now_ts()
        st = tracker.stats()
        state = {
            "health": {"state": "DEGRADED", "source": "replay", "updated_ts": t},
            "counts": {"targets": st["targets"], "msgs_60s": st["msgs_60s"]},
            "targets": tracker.snapshot_targets(),
            "dedupe": {"ek": dedupe_stats},
        }
        atomic_write_json(REMOTEID_STATE_FILE, state)

        if not RID_REPLAY_LOOP:
            break

def expire_worker(tracker: ContactTracker) -> None:
    # Periodically expire contacts even when replay is idle/stopped
    while not _stop.is_set():
        lost_events = tracker.expire()
        if lost_events:
            for ev in lost_events:
                ws_broadcast(ev)
            st = tracker.stats()
            cur = safe_load(REMOTEID_STATE_FILE, {
                "health": {"state":"DEGRADED","source":"replay","updated_ts":now_ts()},
                "counts": {"targets":0,"msgs_60s":0},
                "targets": [],
            })
            dedupe = cur.get("dedupe")
            health = cur.get("health") or {"state":"DEGRADED","source":"replay","updated_ts":now_ts()}
            health["updated_ts"] = now_ts()
            cur["health"] = health
            cur["counts"] = {"targets": st["targets"], "msgs_60s": st["msgs_60s"]}
            cur["targets"] = tracker.snapshot_targets()
            if dedupe is not None:
                cur["dedupe"] = dedupe
            atomic_write_json(REMOTEID_STATE_FILE, cur)
        time.sleep(0.5)

def gpsd_worker() -> None:
    gps_state = {
        "mode": 0,
        "lat": None,
        "lon": None,
        "alt_m": None,
        "speed_mps": None,
        "track_deg": None,
        "sats": None,
        "last_ts": 0,
    }

    def write():
        atomic_write_json(GPS_STATE_FILE, gps_state)

    while not _stop.is_set():
        s = None
        try:
            s = socket.create_connection(("127.0.0.1", 2947), timeout=3)
            s.settimeout(3)
            s.sendall(b'?WATCH={"enable":true,"json":true}\n')
            buf = b""
            while not _stop.is_set():
                chunk = s.recv(4096)
                if not chunk:
                    break
                buf += chunk
                while b"\n" in buf:
                    line, buf = buf.split(b"\n", 1)
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        msg = json.loads(line.decode("utf-8", errors="ignore"))
                    except Exception:
                        continue

                    cls = msg.get("class")
                    if cls == "TPV":
                        gps_state["mode"] = int(msg.get("mode", 0) or 0)
                        gps_state["last_ts"] = now_ts()
                        gps_state["lat"] = msg.get("lat")
                        gps_state["lon"] = msg.get("lon")
                        gps_state["alt_m"] = msg.get("alt")
                        gps_state["speed_mps"] = msg.get("speed")
                        gps_state["track_deg"] = msg.get("track")
                        write()
                    elif cls == "SKY":
                        sats = msg.get("satellites", [])
                        used = 0
                        try:
                            for sat in sats:
                                if sat.get("used"):
                                    used += 1
                        except Exception:
                            used = None
                        gps_state["sats"] = used
                        gps_state["last_ts"] = now_ts()
                        write()

        except Exception:
            gps_state["last_ts"] = now_ts()
            write()
            time.sleep(1.0)
        finally:
            try:
                if s:
                    s.close()
            except Exception:
                pass
            time.sleep(0.5)

# ---- API v1 StatusSnapshot (contract) ----

def now_ms() -> int:
    return int(time.time() * 1000)

def _to_int(v: Any) -> Optional[int]:
    try:
        if v is None:
            return None
        return int(v)
    except Exception:
        return None

def _to_ms(v: Any) -> Optional[int]:
    # Convert seconds (float/int) -> unix ms
    try:
        if v is None:
            return None
        return int(float(v) * 1000)
    except Exception:
        return None

def get_uptime_seconds() -> Optional[float]:
    try:
        with open("/proc/uptime", "r", encoding="utf-8") as f:
            return float(f.read().split()[0])
    except Exception:
        return None

def get_cpu_temp_celsius() -> Optional[float]:
    # Raspberry Pi: thermal_zone0/temp is millideg C
    try:
        with open("/sys/class/thermal/thermal_zone0/temp", "r", encoding="utf-8") as f:
            return float(f.read().strip()) / 1000.0
    except Exception:
        return None

def get_storage_gb(path: str = "/") -> Tuple[Optional[float], Optional[float]]:
    try:
        st = os.statvfs(path)
        total = (st.f_frsize * st.f_blocks) / (1024**3)
        free  = (st.f_frsize * st.f_bavail) / (1024**3)
        return free, total
    except Exception:
        return None, None

def build_status_v0() -> Dict[str, Any]:
    # Must match legacy /status payload keys (do not change)
    remoteid = safe_load(REMOTEID_STATE_FILE, {
        "health": {"state":"DISCONNECTED","source":"replay","updated_ts":None},
        "counts": {"targets":0,"msgs_60s":0},
        "targets": [],
    })
    gps = safe_load(GPS_STATE_FILE, {
        "mode":0,"lat":None,"lon":None,"alt_m":None,
        "speed_mps":None,"track_deg":None,"sats":None,"last_ts":0
    })
    return {"ok": True, "ts": now_ts(), "remoteid": remoteid, "gps": gps}

def to_status_snapshot_v1(v0: Dict[str, Any]) -> Dict[str, Any]:
    ts_ms = now_ms()
    free_gb, total_gb = get_storage_gb("/")
    remoteid = v0.get("remoteid") or {}
    gps = v0.get("gps") or {}

    rid_health = remoteid.get("health") or {}
    rid_counts = remoteid.get("counts") or {}
    rid_status = str(rid_health.get("state") or "DISCONNECTED")
    rid_last_ms = _to_ms(rid_health.get("updated_ts"))

    snap = {
        "timestamp": ts_ms,
        "overall_ok": bool(v0.get("ok")),
        "system": {
            "hostname": socket.gethostname(),
            "version": os.environ.get("NDEFENDER_VERSION") or "dev",
            "uptime_seconds": get_uptime_seconds(),
            "cpu_temp_celsius": get_cpu_temp_celsius(),
            "storage_free_gb": free_gb,
            "storage_total_gb": total_gb,
        },
        "esp32": {
            "status": "DISCONNECTED",
            "rssi_dbm": None,
            "uptime_seconds": None,
        },
        "gps": {
            "mode": _to_int(gps.get("mode")) or 0,
            "satellites": _to_int(gps.get("sats")),
            "hdop": None,
            "latitude": _float(gps.get("lat")),
            "longitude": _float(gps.get("lon")),
            "altitude": _float(gps.get("alt_m")),
            "speed": _float(gps.get("speed_mps")),
            "heading": _float(gps.get("track_deg")),
        },
        "remote_id": {
            "status": rid_status,
            "active_contacts": _to_int(rid_counts.get("targets")) or 0,
            "last_update_ts": rid_last_ms,
        },
        "fpv": {
            "scan_state": "idle",
            "locked_channels": [],
        },
        "replay": {
            "active": True,
        },
    }
    return snap

@app.get("/api/v1/status")
def api_v1_status():
    v0 = build_status_v0()
    return jsonify(to_status_snapshot_v1(v0))

# ---- end API v1 StatusSnapshot ----

@app.get("/status")
def status():
    remoteid = safe_load(REMOTEID_STATE_FILE, {
        "health": {"state":"DISCONNECTED","source":"replay","updated_ts":None},
        "counts": {"targets":0,"msgs_60s":0},
        "targets": [],
    })
    gps = safe_load(GPS_STATE_FILE, {
        "mode":0,"lat":None,"lon":None,"alt_m":None,
        "speed_mps":None,"track_deg":None,"sats":None,"last_ts":0
    })
    return jsonify({"ok": True, "ts": now_ts(), "remoteid": remoteid, "gps": gps})

@sock.route("/ws")
def ws_handler(ws):
    # Send HELLO + snapshot first to avoid broadcast race
    try:
        ws.send(json.dumps({"type":"HELLO","ts":now_ts()}, separators=(",",":")))
    except Exception:
        return

    try:
        if _TRACKER is not None:
            for c in _TRACKER.snapshot_targets():
                ws.send(json.dumps({"type":"RID_CONTACT_NEW","ts":now_ts(),"contact":c}, separators=(",",":")))
    except Exception:
        pass

    with _ws_clients_lock:
        _ws_clients.add(ws)

    try:
        while True:
            msg = ws.receive()
            if msg is None:
                break
            ws.send(json.dumps({"type":"ACK","ts":now_ts()}, separators=(",",":")))
    finally:
        with _ws_clients_lock:
            _ws_clients.discard(ws)

def main():
    os.makedirs(STATE_DIR, exist_ok=True)
    atomic_write_json(REMOTEID_STATE_FILE, {
        "health": {"state":"DISCONNECTED","source":"replay","updated_ts":now_ts()},
        "counts": {"targets":0,"msgs_60s":0},
        "targets": [],
    })
    atomic_write_json(GPS_STATE_FILE, {
        "mode":0,"lat":None,"lon":None,"alt_m":None,
        "speed_mps":None,"track_deg":None,"sats":None,"last_ts":0
    })

    tracker = ContactTracker(ttl_s=RID_TTL_S)
    global _TRACKER
    _TRACKER = tracker

    threading.Thread(target=replay_worker, args=(tracker,), daemon=True).start()
    threading.Thread(target=expire_worker, args=(tracker,), daemon=True).start()
    threading.Thread(target=gpsd_worker, daemon=True).start()

    app.run(host="0.0.0.0", port=APP_PORT, debug=False)

if __name__ == "__main__":
    main()
